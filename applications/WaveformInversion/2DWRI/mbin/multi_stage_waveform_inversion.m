function [mk,T,f,models,models_struct] = multi_stage_waveform_inversion(m0,D,Q,model,f_a,inversion_algorithm,optimization_algorithm,params,label,label_intermediate,save_vars,constraint,P)
% script which can be used for WRI/FWI to invert data using a frequency
% batching strategy. Handles generation of a grid and PML for the selected
% frequency batch, constraints, simple simultaneous source implementation.

% Author: Bas Peters
%         Seismic Laboratory for Imaging and Modeling
%         Department of Earth, Ocean, and Atmosperic Sciences
%         The University of British Columbia
%
% Lat update: January 2016

% You may use this code only under the conditions and terms of the
% license contained in the file LICENSE provided with this source
% code. If you do not agree to these terms you may not use this
% software.

% If you have any questions, errors or disappointing results, email
% (bpeters {at} eos.ubc.ca)

% ___________ Input:  ___________
% m0                        - input model as vector (in slowness squares [s^2/m^2]
% D                         - input 'observed' data (as generated by F.m)
% Q                         - source matrix
% model                     - structure containing information about souces, receivers & model dimensions (see F.m)
% f_a                       - cell array with frequencies used in each batch (for example: f_a{1}=[2 3 4]; . f_a{2}=[3 4 5];
% inversion_algorithm       - one of: 'WRI' or 'FWI' (string)
% optimization algorithm    - method to solve the PDE constrained
% optimization problem:     - one of: 'PG', 'SPG','TMP_lbfgs', 'TMP_NewtonType','PQN' (string)
% params                    - structure with parameter information about how to invert the data
%   params.sim_src          - 1 if simultaneous sources should be used, 0 otherwise
%   params.it_per_batch(i)  - max nr. of iterations per frequency batch 1 entry in avector per batch
%   params.n_sim_src        - number of simultaneous sources to be used
%
% label                     - label (string) to save variables to workspace
% label_intermediate        - label (string) to save intermediate results (needs to be different from label)
% save_vars                 - structure with information about what to save
%   save_vars.workspace     - if 1; save all workspace variables
%   save_vars.model_iters   - if 1; save the model at every iteration of every frequency batch
%   save_vars.model_batch   - if 1; save and output the model at every batch
% constraint                - structure with information about constraints on the model estimate
% 
%
% ________________________________
% ___________ Output:  ___________
% mk                - final model in slowness squared       
% T                 - Time per frequency batch
% f                 - function value per iteration per batch
% models            - if (save_vars.model_iters=1), this is the model for every iteration
% models_struct     - if (save_vars.model_iters=1), this contains the grid information for the corresponding model at every iteration
% ________________________________


%% parse parameters or set defaults
coarsen_grid = 0;
if isfield(params,'coarsen_grid'), coarsen_grid = params.coarsen_grid; end

%% some settings, constant for each frequency batch
mk=m0;
comp_grid=model;

%some general setup for each inversion algorithm
switch inversion_algorithm
    case 'WRI'
        params.wri       = true;     %use WRI. FWI is used when set to false
        params.hessian   = ''; %type of Hessian approximation
        options.wri      = 1;
    case 'FWI'
        params.wri       = false;     %use WRI. FWI is used when set to false
        params.lambda    = [];
        options.wri      = 0;
        params.hessian   = 'gn';
end

% The Two-Metric-Projection (TMP), PQN and SPG algorithms are modified versions of
% http://www.di.ens.fr/~mschmidt/Software/minFunc.html
% with Licence http://www.cs.ubc.ca/~schmidtm/Software/copyright.html
switch optimization_algorithm
    case 'TMP_lbfgs'
        options.method='lbfgs';
        options.numDiff=0;
        options.optTol=1e-4;
        options.suffDec=1e-4;
    case 'TMP_NewtonType'
        options.method='newton';
        options.numDiff=0;
        options.interp=1;
        options.optTol=1e-4;
        options.suffDec=1e-4;
    case 'PQN'
        
    case 'SPG'
        options.useSpectral=1;
        options.memory = 5;
        options.testOpt = 0;
        options.progTol=10*eps;
    case 'SGD'
        options.useSpectral=1;
        options.memory = 10;
        options.testOpt = 0;
        options.progTol=10*eps;
    case 'PG'
        options.useSpectral=0;
        options.curvilinear=1;
        options.memory = 5;
        options.testOpt = 0;
end


%simultaneous source options
if params.sim_src==1 && strcmp(optimization_algorithm,'SGD')~=1
    params.nsrc_orig = model.nsrc;
    params.D_orig    = reshape(D,model.nrec,model.nsrc,length(model.freq)); clear D
    params.Q_orig    = Q;
end

%% optimize
for i=1:length(f_a)
    
    options.maxIter=params.it_per_batch(i);
    
    %set the frquency index to be used at every iteration. These index into model.freq(params.freq_index)
    params.freq_indx=[];
    for z=1:length(f_a{i})
        params.freq_index(z)=find(model.freq==f_a{i}(z));
    end

    
    if coarsen_grid %resample grid to current frequency batch
        %d_stable  = helm_stable_d( mk,'s2/km2',PDEopts.HELM2D_CHEN9P,max(model.freq(params.freq_index)));
        npts_wavelength = 6;
        vmin = min(1e3*(mk(:).^(-1/2)));
        d_stable = [1 1 1]*vmin/(npts_wavelength*max(model.freq(params.freq_index)));
        d_stable(3)=1;
        [f2c,c2f,n_sub] = fine2coarse(model.n,model.d,d_stable,'cubic');
        
        params.pdefunopts.helm_dt = d_stable;
        comp_grid.d=d_stable;
        comp_grid.o=model.o;
        comp_grid.n=n_sub;
        comp_grid.n(3)=1;
        
        min_mk=min(mk(:));
        max_mk=max(mk(:));
        mk=f2c*mk(:);
        mk(mk>max_mk)=max_mk;
        mk(mk<min_mk)=min_mk;
        P_temp = setup_constraints_freq_FWI_2D(constraint,model,comp_grid,params,mk,1);
        mk=P_temp{1}(mk);
    end
    

    % simultaneous source stuff
    if params.sim_src==1  && strcmp(optimization_algorithm,'SGD')~=1
        clear D
        W=randn(params.nsrc_orig,params.n_sim_src)+1i*randn(params.nsrc_orig,params.n_sim_src);
        for fr=1:length(model.freq)
            D(:,:,fr)=params.D_orig(:,:,fr)*W;
        end
        D=D(:);
        Q=params.Q_orig*W;
        comp_grid.nsrc=params.n_sim_src;
    end
    
    % constraint definition
    if i==1;   constraint.m_start=mk; end
    % obtain projectors Projs{1}, P{2}, ... , P{.}
    % funProj is a function handle which projects the input onto the
    % intersection of the constraint sets
    switch constraint.implementation
        case 'dykstra_constraints_mps' % constraints defined in m/s, dykstra runs in m/s
            warning('temporary not supported, will run Dykstra in mixed form')
            constraint.implementation='dykstra_ssq_constraints_mixed';
    end
    
    switch constraint.implementation
        case 'dykstra_constraints_mps' % constraints defined in m/s, dykstra runs in m/s
%             LB = ones(length(mk),1)*(1e6 * ( 1./(constraint.v_max.^2) ));
%             UB = ones(length(mk),1)*(1e6 * ( 1./(constraint.v_min.^2) ));
%             P_box           = @(input) boundProject(input,LB,UB);
%             Projs = setup_constraints_ms(constraint,model,comp_grid,params,1e3./sqrt(P_box(mk)),i);
%             funProj = @(input) P_box(1e6./(Dykstra_prox_parallel((1e3./sqrt(P_box(input))),Projs,constraint.options_dyk).^2));
        case 'dykstra_ssq_constraints_mixed' %dykstra runs in s^2/m^2 constraints which are defined in velocity will be converted and back when projected (this is a slight deviation from the theory, often works well in practice)
            Projs = setup_constraints_freq_FWI_2D(constraint,model,comp_grid,params,mk,i);
            funProj = @(input) Dykstra_prox_parallel(input,Projs,constraint.options_dyk);
        case 'single_constraint'
            [Projs,LB,UB] = setup_constraints_freq_FWI_2D(constraint,model,comp_grid,params,mk,i);
            funProj = @(input) Projs{1}(input);
        otherwise
            error('need to select constraints')
    end
    %make sure the initial guess is in the feasible set (although some
    %algorithms automatically do this)
    [mk] = funProj(mk);
    mk = Projs{1}(mk);
    
    save('model','model')
    %define function handle fh: [f,g]=fh(m), input: model, output: function value, gradient (possibly Hessian approximation)
    switch inversion_algorithm
        case 'WRI'
            %fh = misfit_setup(Q,D,model,params); %function handle which will return objective function, gradient and Hessian for the selected method (WRI/FWI)
            fh_t = misfit_setup(mk,Q,D,model,params); 
            fh =@(input) fh_t(reshape(input,comp_grid.n));
        case 'FWI'
            
            if  strcmp(optimization_algorithm,'SGD')~=1
                fh_t = misfit_setup(mk,Q,D,model,params); %function handle which will return objective function, gradient and Hessian for the selected method (WRI/FWI)
                fh =@(input) fh_t(reshape(input,comp_grid.n));
            end
        case 'FWI_W'
            %nothing here yet (not required)
    end
    
    %optimize current frequency batch
    batch_time_tic=tic;
    switch optimization_algorithm
        case {'TMP_lbfgs','TMP_NewtonType'}
            [mk,obj,funEvals,~,iter_save,obj_aux] = minConf_TMP(fh,mk,LB,UB,options);
        case 'PQN'
            [mk,obj,funEvals,iter_save] = minConf_PQN(fh,mk,funProj,options);
        case 'SPG'
            [mk,obj,funEvals,projects,iter_save] = minConf_SPG(fh,mk,funProj,options);
        case 'PG'
            [mk,obj,funEvals,projects,iter_save] = minConf_SPG(fh,mk,funProj,options);
        case 'SGD'
            fh_info.Q=Q;
            fh_info.D=reshape(D,model.nrec,model.nsrc,length(model.freq));
            fh_info.D=fh_info.D(:,:,params.freq_index);
            fh_info.D=distributed(gather(fh_info.D));
            if params.sim_rec==1; fh_info.P=P; end
            %fh_info.comp_grid=comp_grid;
            fh_info.params=params;
            fh_info.model=comp_grid;
            fh_info.model.freq=model.freq(params.freq_index);
            [mk,obj,funEvals,projects,iter_save] = SGD_like_hack_Gauss(fh_info,mk,funProj,options);
    end
    


    T(i)=toc(batch_time_tic);
    pause(10)
    
    %save errors, objective values and auxilary objective information
    if save_vars.model_iters; models{i} = iter_save; models_struct{i}=comp_grid; end;
    if save_vars.model_batch;  save(['mk_',label_intermediate],'mk'); save(['model_',label_intermediate],'comp_grid'); end;
    f.obj{i}     = obj;
    
    if coarsen_grid
        min_mk=min(mk(:));
        max_mk=max(mk(:));
        mk=c2f*mk(:);
        mk(mk>max_mk)=max_mk;
        mk(mk<min_mk)=min_mk;
    end
    
    if sum(strcmp(inversion_algorithm,{'FWI','FWI_W'}))==1
        f.obj_aux{i}=0;
    else
        f.obj_aux{i} = obj_aux;
    end
end

%% Save results
if save_vars.workspace==1;
    clear D fh U
    params.D_orig = [];
    save(['workspace_',label]);
end;
